<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Notebook</title>
  <style>
    html, body { height: 100%; margin: 0; }
    * { box-sizing: border-box; }
    body {
      background: #000;
      color: #fff; /* normal white font color */
      font: 17px/1.7 monospace; /* monospace type */
      caret-color: #47ff9c;
      overflow: hidden; /* canvas + full-bleed editor */
    }
    /* Whole page is the input */
    #pad {
      position: fixed;
      inset: 0;
      margin: auto; /* centers when width is constrained */
      max-width: 800px; /* or any preferred width */
      width: 100%; /* still responsive */
      padding: 24px 28px;
      outline: none;
      white-space: pre-wrap;
      word-break: break-word;
      overflow: auto;
    }
    
    ::selection { background: rgba(71, 255, 156, 0.25); }
    /* Starfield canvas behind the editor */
    canvas#stars {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: -1; /* behind pad */
    }
  </style>
</head>
<body>
  <canvas id="stars"></canvas>
  <div id="pad" contenteditable="true" spellcheck="false" autocapitalize="off" autocomplete="off" autocorrect="off"></div>

  <script>
    /**
     * Focus and basic typing UX (Tab inserts a tab; page always focused).
     * @returns {void}
     */
    function boot() {
      const pad = document.getElementById('pad');
      pad.focus();
      document.addEventListener('click', () => pad.focus());
      pad.addEventListener('keydown', (ev) => {
        if (ev.key === 'Tab') {
          ev.preventDefault();
          document.execCommand('insertText', false, '\t');
        }
      });
    }
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', boot);
    } else {
      boot();
    }

    // ---- Space warp starfield ----
    const canvas = document.getElementById('stars');
    const ctx = canvas.getContext('2d');

    /**
     * @typedef {Object} Star
     * @property {number} x - Current x position.
     * @property {number} y - Current y position.
     * @property {number} px - Previous x position (for streaks).
     * @property {number} py - Previous y position (for streaks).
     * @property {number} s - Base outward speed.
     * @property {number} r - Render radius when idle.
     */

    /** @type {Star[]} */
    let stars = [];
    let width = 0, height = 0, cx = 0, cy = 0;
    let prevWidth = 0, prevHeight = 0;

    /** Space-warp impulse. Increased on typing, eased every frame. */
    let warp = 0; // dynamic boost
    const WARP_MAX = 18;
    const WARP_IMPULSE = 5.5;
    const WARP_DECAY = 0.90; // per-frame multiplier

    /**
     * Resize the canvas without restarting the starfield.
     * - First time: seed stars.
     * - Later resizes: scale existing star positions; add/remove to match density.
     * This prevents the animation from restarting on soft viewport changes (e.g., virtual keyboard).
     * @returns {void}
     */
    function resize() {
      const newW = window.innerWidth;
      const newH = window.innerHeight;

      // Handle device pixel ratio cleanly (keeps streaks crisp on HiDPI)
      const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      canvas.width = Math.floor(newW * dpr);
      canvas.height = Math.floor(newH * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      // Compute logical size used for our math
      width = newW; height = newH;
      const oldW = prevWidth || width;
      const oldH = prevHeight || height;
      prevWidth = width; prevHeight = height;

      const targetCount = Math.round((width * height) / 9000); // density scales with screen

      if (stars.length === 0) {
        // Initial seed only once
        cx = width / 2; cy = height / 2;
        stars = Array.from({ length: targetCount }, seedStar);
        return;
      }

      // Scale existing positions to preserve motion feel
      const sx = oldW ? width / oldW : 1;
      const sy = oldH ? height / oldH : 1;
      for (let i = 0; i < stars.length; i++) {
        const st = stars[i];
        st.x *= sx; st.y *= sy; st.px *= sx; st.py *= sy;
      }
      cx = width / 2; cy = height / 2;

      // Adjust star count smoothly without full reseed
      if (stars.length < targetCount) {
        const add = targetCount - stars.length;
        for (let i = 0; i < add; i++) stars.push(seedStar());
      } else if (stars.length > targetCount) {
        stars.length = targetCount;
      }
    }

    /**
     * Create a new star near the center with a tiny random offset.
     * @returns {Star}
     */
    function seedStar() {
      const angle = Math.random() * Math.PI * 2;
      const radius = Math.random() * 40; // start close to center
      const x = cx + Math.cos(angle) * radius;
      const y = cy + Math.sin(angle) * radius;
      return {
        x, y, px: x, py: y,
        s: 0.3 + Math.random() * 0.7, // base drift speed
        r: Math.random() * 1.4 + 0.2
      };
    }

    window.addEventListener('resize', resize);
    resize();

    /**
     * Step physics and render one frame.
     * Stars drift outward from the center; on typing, warp increases and
     * we render streaks to simulate hyperspace.
     * @returns {void}
     */
    function frame() {
      // Ease warp boost toward 0
      warp *= WARP_DECAY;
      if (warp < 0.05) warp = 0;

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, width, height);

      const streak = warp > 0.5;

      for (let i = 0; i < stars.length; i++) {
        const st = stars[i];
        st.px = st.x; st.py = st.y;

        // Direction from center
        const dx = st.x - cx;
        const dy = st.y - cy;
        const dist = Math.hypot(dx, dy) || 1;
        const ux = dx / dist;
        const uy = dy / dist;

        // Speed grows with warp; tiny parallax via 1 + dist * 0.0006
        const v = (st.s + warp) * (1 + dist * 0.0006);
        st.x += ux * v;
        st.y += uy * v;

        // Respawn when out of bounds with margin
        if (st.x < -50 || st.x > width + 50 || st.y < -50 || st.y > height + 50) {
          stars[i] = seedStar();
          continue;
        }

        if (streak) {
          // Draw streak from previous point to current
          ctx.beginPath();
          ctx.moveTo(st.px, st.py);
          ctx.lineTo(st.x, st.y);
          ctx.lineWidth = Math.min(2.2, 0.2 + warp * 0.08);
          ctx.strokeStyle = 'rgba(255,255,255,0.9)';
          ctx.stroke();
        } else {
          // Idle tiny dot
          ctx.beginPath();
          ctx.arc(st.x, st.y, st.r, 0, Math.PI * 2);
          ctx.fillStyle = '#fff';
          ctx.fill();
        }
      }

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

    /**
     * Bump the warp when the user types.
     * @returns {void}
     */
    function onTypeWarp() {
      warp = Math.min(WARP_MAX, warp + WARP_IMPULSE);
    }

    // Hook into input on the contenteditable surface
    document.getElementById('pad').addEventListener('input', onTypeWarp);

    // ---- Minimal in-page test harness (console only) ----
    (function runTests() {
      /**
       * Basic assert helper.
       * @param {string} name - Test name.
       * @param {() => boolean} fn - Predicate returning true when the test passes.
       */
      function test(name, fn) {
        try {
          const ok = fn();
          if (ok) console.log('✅', name);
          else console.error('❌', name);
        } catch (e) {
          console.error('❌', name, e);
        }
      }

      // 1) Elements exist
      test('pad exists', () => !!document.getElementById('pad'));
      test('stars canvas exists', () => !!document.getElementById('stars'));

      // 2) Resize does not reseed/restart starfield when size unchanged
      test('resize preserves star array identity with same size', () => {
        const ref = stars;
        const len = stars.length;
        resize();
        return stars === ref && stars.length === len && len > 0;
      });

      // 3) Typing warp increases momentum
      test('onTypeWarp increases warp', () => {
        const before = warp;
        onTypeWarp();
        return warp > before;
      });

      // 4) Frame loop scheduled
      test('animation frame loop scheduled', () => typeof requestAnimationFrame === 'function');
    })();
  </script>
</body>
</html>
